C++ 中常见小问题：

> priority_queue 是`大顶堆`
>
> multiset 的 extract 是去掉一个元素，元素不存在则无操作，返回值为 node_type。
>
> multiset 的 erase 的数值删除用法，会把相同的值都删掉，返回值为 size_type，返回一个指向被删除元素的下一个元素的迭代器。
>
> 可以利用 map 的 emplace 方法返回值
>
> 输出控制： fixed, setprecision, setw, setfill
>
> array 相当于普通数组，局部需要初始化； vector 嵌套则不需要。
>
> mt19937_64 rnd{random_device{}()};


```cpp []
#include <bits/extc++.h>

using PII = pair<int, int>;
__gnu_pbds::tree<PII, __gnu_pbds::null_type, less<PII>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> rbt;
```


01背包：

> 下标从0开始，外层枚举物品，内层枚举背包容量


分组背包：

> 下标从0开始，外层枚举组，中层枚举背包容量，内层枚举组内物品
（由于背包容量中层枚举，此时不清楚物品体积，所以应该在内层枚举物品时判断体积大小）



区间DP：

> 枚举区间长度（从小区间到大区间），注意初始化

划分型DP：

> 判定能否划分：
>
> 一般定义 f[i] 表示长为 i 的前缀 a[:i] 能否划分，枚举最后一个子数组的左端点进行转移。

> 最优划分：
>
> 一般定义 f[i] 表示长为 i 的前缀 a[:i] 在题目约束下，分割出的最少（最多）子数组的个数（或者定义成分割方案数）。
枚举最后一个子数组的左端点，考虑这一段对最优解的影响。

> 将数组分成（恰好/至多）k 个连续子数组，计算与这些子数组有关的最优值。
>
> 一般定义 `f[i][j]` 表示将长为 j 的前缀 a[:j] 分成 i 个连续子数组所得到的最优解。
>
> 枚举最后一个子数组的左端点 L, 从 `f[i−1][L]` 转移到 `f[i][j]`，并考虑 a[L:j] 对最优解的影响。



凡是求方案数的问题一定要初始化。

对于相邻元素差的绝对值之和，考虑能否通过排序简化。

线段树区间修改需要附加懒信息。
