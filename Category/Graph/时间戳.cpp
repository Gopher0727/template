/*-----------------------------------------------------------------------------------*/
// 何为时间戳？
//
// 我们可以在 DFS 一棵树的过程中，维护一个全局的时间戳 clock，每访问一个新的节点，就将 clock 加一。
// 同时，记录进入节点 x 时的时间戳 in[x]，和离开（递归结束）这个节点时的时间戳 out[x]。

/*-----------------------------------------------------------------------------------*/
// 时间戳有什么性质？
//
// 根据 DFS 的性质，当我们递归以 x 为根的子树时，设 y 是 x 的子孙节点，我们必须先递归完以 y 为根的子树，
// 之后才能递归完以 x 为根的子树。
// 从时间戳上看，如果 y 是 x 的子孙节点，那么区间 [in[y], out[y]] 必然被区间 [in[x], out[x]] 所包含。
// 反之，如果区间 [in[y], out[y]] 被区间 [in[x], out[x]] 所包含，那么 y 必然是 x 的子孙节点（也即 x 是 y 的祖先节点）。
// 因此我们可以通过 in[x] < in[y] ≤ out[y] ≤ out[x] 来判断 x 是否为 y 的祖先节点。
// 由于 in[y] ≤ out[y] 恒成立，上式可以简化为 in[x] < in[y] ≤ out[x]。

vector<array<int, 2>> nodes(n);
int clk = 0;
auto dfs = [&](auto&& dfs, int x = 0) -> void {
    nodes[x][0] = clk;
    for (int y : g[x]) {
        dfs(dfs, y);
    }
    nodes[x][1] = clk;
};
dfs(dfs);
